from functools import reduce
from turtle import * # for turtle graphics

# Syntax Rules
"""

Basic Syntax Rules
--------------------

Must be capital letter or digit. May be followed by subscript in LaTeX notation (X'_'{SUB}).

Subscripts may be any string of characters.

Only Single variables may be on the left of the arrow.

Multiple rules will be generated with a '|' on the right
i.e.
A → AA | B
equals
A → AA
A → B

Whitespace is ignored.

LaTeX syntax is always acceptable.

Special curves are pre-programmed. Type the name to run
Sierpinski
Sier Arrowhead
Cantor
Koch
Dragon Curve

Utilizing the Turtle Function
-------------------------------

Variables bound to Turtle Actions:
F_{l}: move forward length l
R_{d}/L_{d}: turn right/left d degrees
P_u/P_d: put pen up/down
M_{...}: perform the module of actions ... in order

Not using subscript uses default values:
F: move forward 10
R/L: turn right/left 90 degrees
P: put pen down

Leading or trailing n in subscript scales with recursive depth
F_{10n}: move forward 10 times the recursive depth of this F

# in subscript allows for tagged variables
F_{1}: move forward one
F_{#1}/F_{#abadhas}: move forward default length, but unique variables
F_{10n #2}/F_{10n #1}: move 10 times recursive depth forward, but unique variables


"""

# maps raw string input to interpreter accepted values
TeX_to_Interpreter = [
    (r"\\", ""),
    ("\ ", " "),
    (" ", ""),
    ("&", ""),
    (r"\rightarrow", "->"),
    (r"\Rightarrow", "->"),
    ("->", "→"),
    (r"\mid", "|")
]

# maps special program names to the grammar input for ease of use
Special_Programs = [
    ("Sierpinski", """S→FL_{120}F_{#}L_{120}F_{#}\nF→FL_{120}F_{#}R_{120}FR_{120}F_{#}L_{120}F\nF_{#}→F_{#}F_{#}"""),
    ("Sier Arrowhead", """F → F_{#2} L_{60} F L_{60} F_{#2}\nF_{#2} → F R_{60} F_{#2} R_{60} F"""),
    ("Koch", """F → F L F R F R F L F"""),
    ("Cantor", """M_{P_dFP_u} -> M_{P_dFP_u}FM_{P_dFP_u}\nF -> FFF"""),
    ("Dragon Curve", """S → F X\nX → X R Y F R\nY → L F X L Y""")
]


# makes raw text ready for parsing
def process_raw(raw):
    for t in TeX_to_Interpreter:
        raw = raw.replace(t[0], t[1])

    return raw


# returns a list of rules generated by a line of text
def parse_line(line):
    if not len(line):
        return []

    line = process_raw(line)

    left = line[:line.index('→')]

    right = line[line.index('→') + 1:]

    return [(left, x) for x in right.split("|")]


# returns a list of rules generated by multi-line text
def create_rules(raw):
    if not len(raw):
        return []

    for name, program in Special_Programs:
        raw = raw.replace(name, program)

    list_of_rule_lists = [parse_line(line) for line in raw.splitlines()]

    return reduce(lambda x, y: x + y, list_of_rule_lists)


# returns the alphabet of variables the rule_list operates over
def sigma(rule_list):
    # gather all variables on the left-hand side
    variables = {t[0] for t in rule_list}

    # for all right-hand sides
    for right in [rule[1] for rule in rule_list]:
        for symbol in split_symbols(right):
            if symbol[0].isupper() or symbol[0].isdigit():
                variables.add(symbol)

    return variables


# breaks a line into an ordered list of variables nd terminals
def split_symbols(raw):
    out = []

    # for each letter in raw
    i = 0
    while i < len(raw):
        # initialize accumulator string
        s = raw[i]

        # fetch subscript (None if no subscript)
        sub = get_subscript(raw, i)

        if sub is not None:
            if raw[i + 2] == '{':
                s += '_{' + sub + '}'
                i += 3 + len(sub)
            else:
                s += '_' + sub
                i += 1 + len(sub)

        # add the final accumulation
        out.append(s)

        i += 1

    return out


# returns the contents of items between brackets, including the brackets
# starting with the bracket at i
def get_enclosed(raw, i):
    prefix_ops, postfix_ops = {'{', '[', '('}, {'}', ']', ')'}

    if raw[i] not in prefix_ops:
        return raw[i]

    # update accumulator
    s = raw[i]

    # for each character after '{' while haven't seen closing '}'
    i += 1
    while True:
        c = raw[i]

        if c in prefix_ops:
            inner = get_enclosed(raw, i)
            s += inner
            i += len(inner)
        else:
            s += c
            i += 1

        if c in postfix_ops:
            return s


# returns the contents the subscript following the prefix at i,
# None if there is no subscript
def get_subscript(raw, i):
    if len(raw) > 2 + i and raw[i + 1] == '_':
        sub = get_enclosed(raw, i + 2)
        return sub[1:-1] if len(sub) > 1 else sub

    return None


# Applies the text form of a single action symbol to a turtle at n where
# n is the depth of the command in the production recursion
def apply_cmd(cmd: str, turtle: Turtle, n):
    sub = get_subscript(cmd, 0)

    # if no subscript, ignore it
    ignore_sub = sub is None

    # if subscript, cut out everything after # sign
    if not ignore_sub and '#' in sub:
        sub = sub[:min(sub.index('#'), len(sub))]

    # if there is no longer a subscript, ignore it
    ignore_sub = ignore_sub or not len(sub)

    # if there is a subscript that contains a depth factor...
    if not ignore_sub and ("n" is sub[0] or "n" is sub[-1]):
        # replace n with the evaluated expression
        sub = sub.replace("n", "")
        sub = str(float(sub) * n)

    # apply the proper command, recurse if module command
    if cmd[0] == 'F':
        turtle.forward(10 if ignore_sub else float(sub))
    elif cmd[0] == 'R':
        turtle.right(90 if ignore_sub else float(sub))
    elif cmd[0] == 'L':
        turtle.left(90 if ignore_sub else float(sub))
    elif cmd[0] == 'P':
        if 'u' in sub:
            turtle.penup()
        else:
            turtle.pendown()
    elif cmd[0] == 'M':
        for M_command in split_symbols(sub):
            apply_cmd(M_command, turtle, n)


# a class that allows an instance of an L-system to be generated
class LSystem:

    # alphabet of LSystem
    sigma = []
    # start variable
    start = None
    # rule set
    rules = []

    def __init__(self, raw):
        self.rules = create_rules(raw)
        self.sigma = sigma(self.rules)
        self.start = self.rules[0][0]

        self.generate_terminators()

    # generates any missing terminator variable rules
    def generate_terminators(self):
        for v in self.sigma:
            if all(i[0] is not v for i in self.rules):
                t = v, v
                self.rules.append(t)

    # generates a dict of the rules in standard CFG format
    def generate_grammar(self):
        grammar = {}

        for rule in self.rules:
            left, right = rule
            if left in grammar:
                grammar[left] += " | " + right
            else:
                grammar[left] = right

        return grammar

    # returns the evaluated L-system after n recursions
    def yields(self, n):
        return self.yields_from(n, self.start)

    # returns the evaluated L-system after n recursions from a start string
    def yields_from(self, n, start):
        if n <= 0:
            return start

        new_s = ""
        for var in split_symbols(start):
            do_continue = False

            for rule in self.rules:
                if rule[0] == var:
                    new_s += rule[1]
                    do_continue = True
                    continue  # to avoid duplicate rules

            if do_continue:
                continue

            new_s += var

        return self.yields_from(n - 1, new_s)

    # runs the turtle on the command string self.yield(n)
    def run_turtle(self, n):
        if not n:
            return

        cmd_str = self.yields(n)

        print("Command String: " + cmd_str)

        win = Screen()
        t = Turtle()

        t.speed(10)

        # for each symbol in the command string, apply to t
        for s in split_symbols(cmd_str):
            apply_cmd(s, t, n)

        win.exitonclick()

    def __str__(self):
        return (self.sigma, self.start, self.rules).__str__()


if __name__ == '__main__':
    print("Enter any L-System Production rule set, starting with the start variable: ")

    # gather an arbitrary number of lines until something followed by empty line is read
    lines = ""
    while not len(lines):
        lines = '\n'.join(iter(input, ""))

    l_system = LSystem(lines)
    print("Generated L-System: ")
    print(l_system)
    print()

    try:
        l_system.run_turtle(int(input("production depth: ")))
    except Terminator:
        print()
        print("------------------")
        print("Turtle execution interrupted")
