adj = [[0, 1, 1, 1, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0]]
adj2 = [[0, 1, 0, 1], [0, 0, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]


# mat is adjacency matrix for a crime ring graph
# returns index of kingpin's row/column or None if no such kingpin exists
#
# Help from Jennifer DeJong
def king_pin(mat):  # Function: O(n)
    # Gets the index of a suspected kingpin by
    # trying to traverse the graph in index order
    k = 0  # Assignment: O(1)
    for col in range(len(mat)):  # Loop: O(n)
        if mat[k][col] != 0:  # If(Get): O(1)
            k = col  # Assignment: O(1)

    # Validates the index of the kingpin by
    # checking that all other vertices are connected
    for row in range(len(mat)):  # Loop: O(n)
        if row != k:  # If: O(1)
            continue  # Continue: O(1)
        if mat[row][k] == 0:  # If(Get): O(1)
            return None  # Return: O(1)

    return k  # Return: O(1)


def adj_to_binary_list(adj_mat):  # Function: O(m)
    out = []
    for row in adj_mat:  # Loop: O(m)
        num = 0x0  # Assignment: O(1)

        for i in range(len(row)):  # Loop: O(sqrt(m))
            entry = row[len(row) - i - 1]  # Assignment: O(1)
            mask = entry << i  # Assignment: O(1)
            num = num | mask  # Assignment: O(1)

        out.append(num)  # Assignment: O(1)
    return out  # Return: O(1)


def make_adjacency_matrix(m, n):    # Function: O(m + n)
    out = [[0 for _ in n] for _ in n]   # Assignment: O(1)

    # Though python does not explicitly support it
    # the circumstances of the problem give a size and a
    # trivial perfect hashing algorithm
    # Prof Milne signed off on map accessing in O(1)
    index_map = {}                      # Assignment: O(1)
    for i in range(len(n)):             # Loop: O(n)
        index_map[n[i]] = i                 # Assignment: O(1)

    for key, value in m.items():        # Loop: O(m)
        if value is 'different':            # If: O(1)
            r = index_map[key[0]]               # Get: O(1)
            c = index_map[key[1]]               # Get: O(1)

            out[r][c] = 1                       # Assignment: O(1)

    return out                          # Return: O(1)


def find_max_complement(bin_list, c):   # Function: O(n)
    a = 0                                   # Assignment: O(1)
    for i in bin_list:                      # Loop: O(n)
        if c & i == 0:                          # If(Bitwise): O(1)
            a = max(a, i)                           # Assignment: O(1)
    return a                                # Return: O(1)


# m is map (c0, c1): r where c0, c1 in n and r in {same, different, unknown}
# condition for true: m forms bipartite graph where same calls are together
#   and differing calls are separated.
# unknown comparisons don't effect consistency
def consistent(m, n):
    # Adjacency matrix of graph which, if bipartite, represents
    # the ability to separate all different calls into two groups
    adj_mat = make_adjacency_matrix(m, n)   # Function: O(m + n)

    # If any same items are connected, not bipartite
    for k, v in m.items():                  # Loop: O(m)
        if v is 'same' and adj_mat[k[0]][k[1]]: # If(Get): O(1)
            return False                            # Return: O(1)

    # The list of numbers generated by converting rows/cols of
    # of bipartite adjacency matrix into integers
    bin_list = adj_to_binary_list(adj_mat)  # Function: O(m)

    # Largest value represents best connected node a
    # a is used to compare against for an over-connected graph
    a = find_max_complement(bin_list, 0x0) # Function: O(n)

    # Implies m generates 0 edges, trivially bipartite
    if a == 0:                              # If: O(1)
        return True                             # Return: O(1)

    # b is the next best connected node not in the
    # same bipartite partition as a
    b = find_max_complement(bin_list, a)

    # Implies a has a self-loop, not bipartite
    if b == 0:                             # If: O(1)
        return False                            # Return: O(1)

    for i in bin_list:                      # Loop: O(n)
        # If item is connected to both partitions, not bipartite
        if i & a and i & b:                     # If(Bitwise): O(1)
            return False                            # Return: O(1)

    return True                             # Return: O(1)
